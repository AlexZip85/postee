{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\u00b6 Postee is a simple message routing application that receives input messages through a webhook interface, and can take enforce actions using predefined outputs via integrations. Primary use of Postee is to act as a message relay and notification service that integrates with a variety of third-party services. Postee can also be used for sending vulnerability scan results or audit alerts from Aqua Platform to collaboration systems. In addition, Postee can also be used to enforce pre-defined behaviours that can orchestrate actions based on input messages as triggers.","title":"Introduction"},{"location":"#_1","text":"Postee is a simple message routing application that receives input messages through a webhook interface, and can take enforce actions using predefined outputs via integrations. Primary use of Postee is to act as a message relay and notification service that integrates with a variety of third-party services. Postee can also be used for sending vulnerability scan results or audit alerts from Aqua Platform to collaboration systems. In addition, Postee can also be used to enforce pre-defined behaviours that can orchestrate actions based on input messages as triggers.","title":""},{"location":"actions/","text":"Motivation \u00b6 Proper alert management can help security practitioners make informed decisions about their codebase. However, security alerts can cause fatigue if acting on them isn\u2019t possible. Postee, an open source security alert management tool, helps mitigate some of those concerns. It enables teams to define routes and rules by which alerts are handled and redirected to User Stories \u00b6 In a typical Postee setup, users can configure the tool to receive events from a variety of sources over a webhook. This allows for ease of use in existing environments. Furthermore, users can configure Postee to process these incoming events and, based on logic defined via Rego rules, send them to different actions. As a Postee User I want , to be able to remove a vulnerable image from my cluster upon a Trivy scan So that , I can keep such images unavailable for deployment. I want , to ship Tracee security notification logs from my node when events are detected So that , I can build a timelog for forensics purposes. I want , to be able to add labels to my deployments when Starboard detects a vulnerable image in my cluster So that , I can effectively tag my resources. Actions are remote services that messages should be sent to. Each action has two mandatory fields, which are 'name' and 'type'. Key Description Possible Values Example name Unique name of the action. This name is used in the route definition. Any string teams-action type The type of the action You can choose from the following types: email, jira, slack, teams, webhook, splunk, serviceNow email Tip Depending on the 'type', additional parameters are required. Jira \u00b6 Follow these steps to set up JIRA integration: Get a new token for user: Login to Jira Cloud. Go to the user profile API tokens (JIRA Cloud users can find it here ). Click on the Create API Token. A new API token for the user is created. Login to Jira Server/Data center Select your profile picture at top right of the screen, then choose Settings > Personal Access Tokens. Select Create token. Give your new token a name. Optionally, for security reasons, you can set your token to automatically expire after a set number of days. Click Create. A new PAT for the user is created. Fill jira action in cfg.yaml: Jira Cloud: User: your email. Password: your API token. Jira Server/Data center: User: your UserName. Password: your Password.\\ or Token: your Personal Access Tokens. Key Description Possible Values url Jira project url project-key The JIRA project key user Jira user. Use email for Jira Cloud and UserName for Jira Server/Data Center password Optional: User's password. API token can also be used for Cloud Jira instances. token Optional: User's Personal Access Token. Used only for Jira Server/Data Center board Optional: JIRA board key priority Optional: ticket priority, e.g., High assignee Optional: comma separated list of users (emails) that will be assigned to ticket, e.g., [\"john@yahoo.com\"]. To assign a ticket to the Application Owner email address (as defined in Aqua Application Scope, owner email field), specify [\"<%application_scope_owner%>\"] as the assignee value issuetype Optional: issue type, e.g., Bug labels Optional: comma separated list of labels that will be assigned to ticket, e.g., [\"label1\", \"label2\"] sprint Optional: Sprint name, e.g., \"3.5 Sprint 8\" For Jira you can also specify custom fields that will be populated with values. Use the unknowns parameter in cfg.yaml for custom fields. Under the unknowns parameter, specify the list of fields names to provide value for. Field name can contains spaces. Possible options for getting the field name: Get field name from Jira UI Move to your jira. Navigate to Settings ( ) > Issues > Custom fields under the Fields section: Click on the required field. Get value from Name field. Get field name from Jira REST API Get all Jira fields according to instructions Find needed field: ... \"id\": \"customfield_10014\", \"key\": \"customfield_10014\", \"name\": \"Epic Link\", \"untranslatedName\": \"Epic Link\", \"custom\": true, \"orderable\": true, \"navigable\": true, \"searchable\": true, \"clauseNames\": [ \"cf[10014]\", \"Epic Link\" ], \"schema\": { \"type\": \"any\", \"custom\": \"com.pyxis.greenhopper.jira:gh-epic-link\", \"customId\": 10014 } }, ... 3. Get value from Name field. Example of using the unknowns parameter in the cfg.yaml file: unknowns : Epic Link : \"K8S-1\" Tip You can add \"-numeric-field\", \"-multiple-value\", \"multiple-line-text-field\", \"-date-time-picker\" and \"-field-url\" as suffix to the custom field name, to specify what is the field type. For example: unknowns : mycustom : \"this is a text custom field\" mycustom-numeric-field : 123 mycustom-multiple-value : 1,2,3 mycustom-multiple-line-text-field : \"text \\n moretext\" mycustom-date-time-picker : 2014-04-11T12:14:26.880+0400 mycustom-url : https://tour.golang.org/moretypes/7 Email \u00b6 Key Description Possible Values use-mx Whether to send the email as an SMTP server or a client. Specify 'true' if you would like to send email as an smtp server, in this case you don't need to provide user, password, host and port. true, false user Optional, if auth supported. User name (usually email address) password Optional, if auth supported. Password host SMTP host name port SMTP port sender Sender's email address recipients Recipients (array of comma separated emails), e.g. [\"john@yahoo.com\"]. To send the email to the Application Owner email address (as defined in Aqua Application Scope, owner email field), specify [\"<%application_scope_owner%>\"] as the recipients value Slack \u00b6 Getting the Slack webhooks Create a Slack Custom App . Copy webhook url to the Postee config Key Description Possible Values url Slack WebHook URL (includes the access key) MS Teams \u00b6 Open your Microsoft Teams client. Click on the \"...\" near the channel you would like to send notifications to. Choose \"Connectors\". The connectors window will open. Look for the \"Incoming Webhook\" connector (it is under the \"All\" category). Click \"Add\" near the Incoming Webhook connector. Click \"Add\" again. Provide a name and click \"Create\". You will be provided with a URL address. Copy this URL and put it in the cfg.yaml. Key Description Possible Values url MS Teams WebHook URL Splunk \u00b6 You will need to care about an HTTP Event Collector in Splunk Enterprise or Splunk Cloud. Tip This can usually be found in the Splunk console under \"Settings -> Data Inputs -> HTTP Event Collector -> Add New\". Once you create an HTTP Event Collector you will receive a token. You should provide this token, together with the Splunk HTTP Collector URL, as part of the cfg.yaml settings. Key Description Possible Values token The Splunk HTTP event collector token url URL to Splunk HTTP event collector (e.g. http://server:8088) size-limit Optional. Maximum scan length, in bytes. Default: 10000 10000 ServiceNow \u00b6 Key Description Possible Values user ServiceNow user name password User API key / password instance Name of ServiceNow Instance (usually the XXX at XXX.servicenow.com) board ServiceNow board name to open tickets on. Default is \"incident\" Nexus IQ \u00b6 Key Description Possible Values user Nexus IQ user name password Nexus IQ password url Url of Nexus IQ server organization-id Organization UID like \"222de33e8005408a844c12eab952c9b0\" Exec \u00b6 Option Usage env Optional, custom environment variables to be exposed in the shell of the executing script input-file Required, custom shell script to executed exec-script Required, inline shell script executed The Exec Action also internally exposes the $POSTEE_EVENT environment variable with the input event that triggered the action. This can be helpful in situations where the event itself contains useful information. Below is an example of using $POSTEE_EVENT . It uses the inline exec-script script: HTTP \u00b6 Option Usage URL Required, URL of the remote server Method Required, e.g., GET, POST Headers Optional, custom headers to send Timeout Optional, custom timeout for HTTP call Bodyfile Optional, input file for HTTP post body Kubernetes \u00b6 Option Usage kube-namespace Required. Kubernetes namespace to use. kube-config-file Required. Path to .kubeconfig file kube-label-selector Required, if specifying labels or annotations. kube-actions Optional, key-value pair of labels and annotations Labels must be added via \"labels\" key and Annotations via \"annotations\". Docker \u00b6 Option Usage docker-image-name Required. Image name of the docker image. docker-cmd Required. Command to run inside the docker image. docker-env Optional. Environment variables to set in the container. docker-network Optional. Connect the action container to the specified network. docker-volume-mounts Optional*. Volume mounts present inside the container. * If you have specified volume mounts, you also need to pass them through into the postee docker container Note When running Postee in a Docker container, it is required to mount the Docker socket within the Postee container to be able to spin up Docker Action container instances. This can be done as follows: docker run --rm --name=postee --group-add $(stat -c '%g' /var/run/docker.sock) -v /var/run/docker.sock:/var/run/docker.sock -v /path/to/cfg.yaml:/config/cfg.yaml -e POSTEE_CFG=/config/cfg.yaml -e POSTEE_HTTP=0.0.0.0:8084 -e POSTEE_HTTPS=0.0.0.0:8444 -p 8084:8084 -p 8444:8444 aquasecurity/postee:latest Tip If you have specified volume mounts for a docker container and use Postee in a docker container as well, remember to mount them within the Postee container as well: docker run --rm --name=postee --group-add $(stat -c '%g' /var/run/docker.sock) -v /var/run/docker.sock:/var/run/docker.sock -v /path/to/cfg.yaml:/config/cfg.yaml -v /my/custom/volume:/my/custom/volume -e POSTEE_CFG=/config/cfg.yaml -e POSTEE_HTTP=0.0.0.0:8084 -e POSTEE_HTTPS=0.0.0.0:8444 -p 8084:8084 -p 8444:8444 aquasecurity/postee:latest Generic Webhook \u00b6 Key Description Possible Values url Webhook URL timeout Webhook timeout Tip The generic webhook action can be used for sending Postee output to any endpoint that can receive a request. You can find some interesting examples as part of the Postee Blueprints","title":"Actions"},{"location":"actions/#motivation","text":"Proper alert management can help security practitioners make informed decisions about their codebase. However, security alerts can cause fatigue if acting on them isn\u2019t possible. Postee, an open source security alert management tool, helps mitigate some of those concerns. It enables teams to define routes and rules by which alerts are handled and redirected to","title":"Motivation"},{"location":"actions/#user-stories","text":"In a typical Postee setup, users can configure the tool to receive events from a variety of sources over a webhook. This allows for ease of use in existing environments. Furthermore, users can configure Postee to process these incoming events and, based on logic defined via Rego rules, send them to different actions. As a Postee User I want , to be able to remove a vulnerable image from my cluster upon a Trivy scan So that , I can keep such images unavailable for deployment. I want , to ship Tracee security notification logs from my node when events are detected So that , I can build a timelog for forensics purposes. I want , to be able to add labels to my deployments when Starboard detects a vulnerable image in my cluster So that , I can effectively tag my resources. Actions are remote services that messages should be sent to. Each action has two mandatory fields, which are 'name' and 'type'. Key Description Possible Values Example name Unique name of the action. This name is used in the route definition. Any string teams-action type The type of the action You can choose from the following types: email, jira, slack, teams, webhook, splunk, serviceNow email Tip Depending on the 'type', additional parameters are required.","title":"User Stories"},{"location":"actions/#jira","text":"Follow these steps to set up JIRA integration: Get a new token for user: Login to Jira Cloud. Go to the user profile API tokens (JIRA Cloud users can find it here ). Click on the Create API Token. A new API token for the user is created. Login to Jira Server/Data center Select your profile picture at top right of the screen, then choose Settings > Personal Access Tokens. Select Create token. Give your new token a name. Optionally, for security reasons, you can set your token to automatically expire after a set number of days. Click Create. A new PAT for the user is created. Fill jira action in cfg.yaml: Jira Cloud: User: your email. Password: your API token. Jira Server/Data center: User: your UserName. Password: your Password.\\ or Token: your Personal Access Tokens. Key Description Possible Values url Jira project url project-key The JIRA project key user Jira user. Use email for Jira Cloud and UserName for Jira Server/Data Center password Optional: User's password. API token can also be used for Cloud Jira instances. token Optional: User's Personal Access Token. Used only for Jira Server/Data Center board Optional: JIRA board key priority Optional: ticket priority, e.g., High assignee Optional: comma separated list of users (emails) that will be assigned to ticket, e.g., [\"john@yahoo.com\"]. To assign a ticket to the Application Owner email address (as defined in Aqua Application Scope, owner email field), specify [\"<%application_scope_owner%>\"] as the assignee value issuetype Optional: issue type, e.g., Bug labels Optional: comma separated list of labels that will be assigned to ticket, e.g., [\"label1\", \"label2\"] sprint Optional: Sprint name, e.g., \"3.5 Sprint 8\" For Jira you can also specify custom fields that will be populated with values. Use the unknowns parameter in cfg.yaml for custom fields. Under the unknowns parameter, specify the list of fields names to provide value for. Field name can contains spaces. Possible options for getting the field name: Get field name from Jira UI Move to your jira. Navigate to Settings ( ) > Issues > Custom fields under the Fields section: Click on the required field. Get value from Name field. Get field name from Jira REST API Get all Jira fields according to instructions Find needed field: ... \"id\": \"customfield_10014\", \"key\": \"customfield_10014\", \"name\": \"Epic Link\", \"untranslatedName\": \"Epic Link\", \"custom\": true, \"orderable\": true, \"navigable\": true, \"searchable\": true, \"clauseNames\": [ \"cf[10014]\", \"Epic Link\" ], \"schema\": { \"type\": \"any\", \"custom\": \"com.pyxis.greenhopper.jira:gh-epic-link\", \"customId\": 10014 } }, ... 3. Get value from Name field. Example of using the unknowns parameter in the cfg.yaml file: unknowns : Epic Link : \"K8S-1\" Tip You can add \"-numeric-field\", \"-multiple-value\", \"multiple-line-text-field\", \"-date-time-picker\" and \"-field-url\" as suffix to the custom field name, to specify what is the field type. For example: unknowns : mycustom : \"this is a text custom field\" mycustom-numeric-field : 123 mycustom-multiple-value : 1,2,3 mycustom-multiple-line-text-field : \"text \\n moretext\" mycustom-date-time-picker : 2014-04-11T12:14:26.880+0400 mycustom-url : https://tour.golang.org/moretypes/7","title":"Jira"},{"location":"actions/#email","text":"Key Description Possible Values use-mx Whether to send the email as an SMTP server or a client. Specify 'true' if you would like to send email as an smtp server, in this case you don't need to provide user, password, host and port. true, false user Optional, if auth supported. User name (usually email address) password Optional, if auth supported. Password host SMTP host name port SMTP port sender Sender's email address recipients Recipients (array of comma separated emails), e.g. [\"john@yahoo.com\"]. To send the email to the Application Owner email address (as defined in Aqua Application Scope, owner email field), specify [\"<%application_scope_owner%>\"] as the recipients value","title":"Email"},{"location":"actions/#slack","text":"Getting the Slack webhooks Create a Slack Custom App . Copy webhook url to the Postee config Key Description Possible Values url Slack WebHook URL (includes the access key)","title":"Slack"},{"location":"actions/#ms-teams","text":"Open your Microsoft Teams client. Click on the \"...\" near the channel you would like to send notifications to. Choose \"Connectors\". The connectors window will open. Look for the \"Incoming Webhook\" connector (it is under the \"All\" category). Click \"Add\" near the Incoming Webhook connector. Click \"Add\" again. Provide a name and click \"Create\". You will be provided with a URL address. Copy this URL and put it in the cfg.yaml. Key Description Possible Values url MS Teams WebHook URL","title":"MS Teams"},{"location":"actions/#splunk","text":"You will need to care about an HTTP Event Collector in Splunk Enterprise or Splunk Cloud. Tip This can usually be found in the Splunk console under \"Settings -> Data Inputs -> HTTP Event Collector -> Add New\". Once you create an HTTP Event Collector you will receive a token. You should provide this token, together with the Splunk HTTP Collector URL, as part of the cfg.yaml settings. Key Description Possible Values token The Splunk HTTP event collector token url URL to Splunk HTTP event collector (e.g. http://server:8088) size-limit Optional. Maximum scan length, in bytes. Default: 10000 10000","title":"Splunk"},{"location":"actions/#servicenow","text":"Key Description Possible Values user ServiceNow user name password User API key / password instance Name of ServiceNow Instance (usually the XXX at XXX.servicenow.com) board ServiceNow board name to open tickets on. Default is \"incident\"","title":"ServiceNow"},{"location":"actions/#nexus-iq","text":"Key Description Possible Values user Nexus IQ user name password Nexus IQ password url Url of Nexus IQ server organization-id Organization UID like \"222de33e8005408a844c12eab952c9b0\"","title":"Nexus IQ"},{"location":"actions/#exec","text":"Option Usage env Optional, custom environment variables to be exposed in the shell of the executing script input-file Required, custom shell script to executed exec-script Required, inline shell script executed The Exec Action also internally exposes the $POSTEE_EVENT environment variable with the input event that triggered the action. This can be helpful in situations where the event itself contains useful information. Below is an example of using $POSTEE_EVENT . It uses the inline exec-script script:","title":"Exec"},{"location":"actions/#http","text":"Option Usage URL Required, URL of the remote server Method Required, e.g., GET, POST Headers Optional, custom headers to send Timeout Optional, custom timeout for HTTP call Bodyfile Optional, input file for HTTP post body","title":"HTTP"},{"location":"actions/#kubernetes","text":"Option Usage kube-namespace Required. Kubernetes namespace to use. kube-config-file Required. Path to .kubeconfig file kube-label-selector Required, if specifying labels or annotations. kube-actions Optional, key-value pair of labels and annotations Labels must be added via \"labels\" key and Annotations via \"annotations\".","title":"Kubernetes"},{"location":"actions/#docker","text":"Option Usage docker-image-name Required. Image name of the docker image. docker-cmd Required. Command to run inside the docker image. docker-env Optional. Environment variables to set in the container. docker-network Optional. Connect the action container to the specified network. docker-volume-mounts Optional*. Volume mounts present inside the container. * If you have specified volume mounts, you also need to pass them through into the postee docker container Note When running Postee in a Docker container, it is required to mount the Docker socket within the Postee container to be able to spin up Docker Action container instances. This can be done as follows: docker run --rm --name=postee --group-add $(stat -c '%g' /var/run/docker.sock) -v /var/run/docker.sock:/var/run/docker.sock -v /path/to/cfg.yaml:/config/cfg.yaml -e POSTEE_CFG=/config/cfg.yaml -e POSTEE_HTTP=0.0.0.0:8084 -e POSTEE_HTTPS=0.0.0.0:8444 -p 8084:8084 -p 8444:8444 aquasecurity/postee:latest Tip If you have specified volume mounts for a docker container and use Postee in a docker container as well, remember to mount them within the Postee container as well: docker run --rm --name=postee --group-add $(stat -c '%g' /var/run/docker.sock) -v /var/run/docker.sock:/var/run/docker.sock -v /path/to/cfg.yaml:/config/cfg.yaml -v /my/custom/volume:/my/custom/volume -e POSTEE_CFG=/config/cfg.yaml -e POSTEE_HTTP=0.0.0.0:8084 -e POSTEE_HTTPS=0.0.0.0:8444 -p 8084:8084 -p 8444:8444 aquasecurity/postee:latest","title":"Docker"},{"location":"actions/#generic-webhook","text":"Key Description Possible Values url Webhook URL timeout Webhook timeout Tip The generic webhook action can be used for sending Postee output to any endpoint that can receive a request. You can find some interesting examples as part of the Postee Blueprints","title":"Generic Webhook"},{"location":"advanced/","text":"This page covers some advanced topics that the experienced users of Postee might like to try. Using environment variables in Postee Configuration File \u00b6 Postee supports use of environment variables for Output fields: User , Password and Token . Add prefix $ to the environment variable name in the configuration file, for example: actions: - name: my-jira type: jira enable: true user: $JIRA_USERNAME token: $JIRA_SERVER_TOKEN Customizing Templates \u00b6 Postee loads bundle of templates from rego-templates folder. This folder includes several templates shipped with Postee, which can be used out of the box. You can add additional custom templates by placing Rego file under the 'rego-templates' directory. To create your own template, you should create a new file under the 'rego-templates' directory, and use the Rego language for the actual template code. Message payload is referenced as input when template is rendered. The result variable should be used to store the output message, which is the result of the template formatting. The following variables should be defined in the custom Rego template. Key Description Type result message body Can be either string or json title message title string aggregation_pkg reference to package used to aggregate messages (when aggregate-message-timeout or aggregate-message-number options are used). If it's missed then aggregation feature is not supported valid rego package So the simplest example of Rego template would look like: package example.vuls.html title:=\"Vulnerabilities are found\" result:=sprintf(\"Vulnerabilities are found while scanning of image: <i>%s</i>\", [input.image]) Two examples are shipped with the app. One produces output for slack integration and another one builds html output which can be used across several integrations. These example can be used as starting point for message customization Data Persistence \u00b6 The Postee container uses BoltDB to store information about previously scanned images. This is used to prevent resending messages that were already sent before. The size of the database can grow over time. Every image that is saved in the database uses 20K of storage. Postee supports \u2018PATH_TO_DB\u2019 environment variable to change the database directory. To use, set the \u2018PATH_TO_DB\u2019 environment variable to point to the database file, for example: PATH_TO_DB=\"./database/webhook.db\". By default, the directory for the database file is \u201c/server/database/webhook.db\u201d. Tip If you would like to persist the database file between restarts of the Postee container, then you should use a persistent storage option to mount the \"/server/database\" directory of the container. The \"deploy/kubernetes\" directory in this project contains an example deployment that includes a basic Host Persistency.","title":"Advanced"},{"location":"advanced/#using-environment-variables-in-postee-configuration-file","text":"Postee supports use of environment variables for Output fields: User , Password and Token . Add prefix $ to the environment variable name in the configuration file, for example: actions: - name: my-jira type: jira enable: true user: $JIRA_USERNAME token: $JIRA_SERVER_TOKEN","title":"Using environment variables in Postee Configuration File"},{"location":"advanced/#customizing-templates","text":"Postee loads bundle of templates from rego-templates folder. This folder includes several templates shipped with Postee, which can be used out of the box. You can add additional custom templates by placing Rego file under the 'rego-templates' directory. To create your own template, you should create a new file under the 'rego-templates' directory, and use the Rego language for the actual template code. Message payload is referenced as input when template is rendered. The result variable should be used to store the output message, which is the result of the template formatting. The following variables should be defined in the custom Rego template. Key Description Type result message body Can be either string or json title message title string aggregation_pkg reference to package used to aggregate messages (when aggregate-message-timeout or aggregate-message-number options are used). If it's missed then aggregation feature is not supported valid rego package So the simplest example of Rego template would look like: package example.vuls.html title:=\"Vulnerabilities are found\" result:=sprintf(\"Vulnerabilities are found while scanning of image: <i>%s</i>\", [input.image]) Two examples are shipped with the app. One produces output for slack integration and another one builds html output which can be used across several integrations. These example can be used as starting point for message customization","title":"Customizing Templates"},{"location":"advanced/#data-persistence","text":"The Postee container uses BoltDB to store information about previously scanned images. This is used to prevent resending messages that were already sent before. The size of the database can grow over time. Every image that is saved in the database uses 20K of storage. Postee supports \u2018PATH_TO_DB\u2019 environment variable to change the database directory. To use, set the \u2018PATH_TO_DB\u2019 environment variable to point to the database file, for example: PATH_TO_DB=\"./database/webhook.db\". By default, the directory for the database file is \u201c/server/database/webhook.db\u201d. Tip If you would like to persist the database file between restarts of the Postee container, then you should use a persistent storage option to mount the \"/server/database\" directory of the container. The \"deploy/kubernetes\" directory in this project contains an example deployment that includes a basic Host Persistency.","title":"Data Persistence"},{"location":"aquacloud/","text":"Configure the Aqua Server with Webhook Integration \u00b6 Postee can be integrated with Aqua Console to deliver vulnerability and audit messages to target systems. You can configure the Aqua Server to send a Webhook notification whenever a new vulnerability is found. Navigate to the Image Scan Results Webhook page, under the \"Settings\" menu. Click \"Enable sending image scan results to webhook\", and specify the URL of Postee. Now, scan an image and look at the Postee log files - you will see that Postee have received an incoming message once scan is done, and that the message was routed based on the cfg.yaml configuration. You can also configure the Aqua Server to send a Webhook notification for every audit message. Navigate to the Log Management page, under the \"Integrations\" menu. Click on the \"Webhook\" item, and specify the URL of Postee. Now every audit event in Aqua will be sent to Postee. You can configure routes and input message conditions in Postee cfg.yaml to forward appropriate messages to target systems. The Postee URL is in the following formats: https://<Postee IP or DNS>:8445 http://<Postee IP or DNS>:8082 Tip For more details about the Postee URL installed using kubernetes click here Validate the Integration \u00b6 To validate that the integration is working, you can scan a new image for security vulnerabilities from the Aqua Server UI (Images > Add Image > Specify Image Name > Add). When vulnerabilities are found in an image, you will see that a JIRA ticket is created/ Email is received/ Slack message is posted to the channel. Tip To troubleshoot the integration, you can look at both the Aqua Postee container logs and the Aqua Server logs. Use the \"docker logs \" command to view these logs.*","title":"Aqua Cloud"},{"location":"aquacloud/#configure-the-aqua-server-with-webhook-integration","text":"Postee can be integrated with Aqua Console to deliver vulnerability and audit messages to target systems. You can configure the Aqua Server to send a Webhook notification whenever a new vulnerability is found. Navigate to the Image Scan Results Webhook page, under the \"Settings\" menu. Click \"Enable sending image scan results to webhook\", and specify the URL of Postee. Now, scan an image and look at the Postee log files - you will see that Postee have received an incoming message once scan is done, and that the message was routed based on the cfg.yaml configuration. You can also configure the Aqua Server to send a Webhook notification for every audit message. Navigate to the Log Management page, under the \"Integrations\" menu. Click on the \"Webhook\" item, and specify the URL of Postee. Now every audit event in Aqua will be sent to Postee. You can configure routes and input message conditions in Postee cfg.yaml to forward appropriate messages to target systems. The Postee URL is in the following formats: https://<Postee IP or DNS>:8445 http://<Postee IP or DNS>:8082 Tip For more details about the Postee URL installed using kubernetes click here","title":"Configure the Aqua Server with Webhook Integration"},{"location":"aquacloud/#validate-the-integration","text":"To validate that the integration is working, you can scan a new image for security vulnerabilities from the Aqua Server UI (Images > Add Image > Specify Image Name > Add). When vulnerabilities are found in an image, you will see that a JIRA ticket is created/ Email is received/ Slack message is posted to the channel. Tip To troubleshoot the integration, you can look at both the Aqua Postee container logs and the Aqua Server logs. Use the \"docker logs \" command to view these logs.*","title":"Validate the Integration"},{"location":"config/","text":"When Postee receives a message it will process it based on routing rules and send it to the appropriate target. How does it know how to do that? Well, this information is defined in Postee's configuration file, cfg.yaml , which contains the following definitions: General settings Routes Templates Actions These sections will be described in detail as we proceed through the documentation.","title":"Config File"},{"location":"demo/","text":"In this demo, we\u2019ll walk through a scenario in which a user wants to act on a security event received from Tracee, an open source runtime security tool. In this scenario, the user will set up the Postee Exec Action to save logs for forensic purposes and then use the Postee HTTP Action to ship the saved logs to a remote server. In this case, the incoming security event from Tracee is received by Postee and evaluated by the following route YAML definition: As seen above, the route has a Rego rule that evaluates the input to contain a certain signature ID, TRC-2, which represents anti-debugging activity. In addition, if the input is matched, the output is triggered. Exec Action \u00b6 In this case, we call the Exec Action first and then the HTTP Action. They are defined as the following: The Exec Action can take in the following parameters: Option Usage env Optional, custom environment variables to be exposed in the shell of the executing script input-file Required, custom shell script to executed exec-script Required, inline shell script executed The Exec Action also internally exposes the $POSTEE_EVENT environment variable with the input event that triggered the action. This can be helpful in situations where the event itself contains useful information. Below is an example of using $POSTEE_EVENT . It uses the inline exec-script script: As you can see, we capture the incoming Postee event and write this event to the Tracee event log for forensic purposes. HTTP Action \u00b6 Finally, we can configure the Postee HTTP Post Action to ship the captured event logs via our HTTP Action to our remote server. Option Usage URL Required, URL of the remote server Method Required, e.g., GET, POST Headers Optional, custom headers to send Timeout Optional, custom timeout for HTTP call Bodyfile Optional, input file for HTTP post body To run Postee in the container, we can invoke the Postee Docker container: docker run --rm --name=postee \\ -v <path-to-cfg>:/config/cfg-actions.yaml \\ -e POSTEE_CFG=/config/cfg-actions.yaml \\ -e POSTEE_HTTP=0.0.0.0:8084 \\ -e POSTEE_HTTPS=0.0.0.0:8444 \\ -p 8084:8084 -p 8444:8444 aquasecurity/postee:latest","title":"Demo"},{"location":"demo/#exec-action","text":"In this case, we call the Exec Action first and then the HTTP Action. They are defined as the following: The Exec Action can take in the following parameters: Option Usage env Optional, custom environment variables to be exposed in the shell of the executing script input-file Required, custom shell script to executed exec-script Required, inline shell script executed The Exec Action also internally exposes the $POSTEE_EVENT environment variable with the input event that triggered the action. This can be helpful in situations where the event itself contains useful information. Below is an example of using $POSTEE_EVENT . It uses the inline exec-script script: As you can see, we capture the incoming Postee event and write this event to the Tracee event log for forensic purposes.","title":"Exec Action"},{"location":"demo/#http-action","text":"Finally, we can configure the Postee HTTP Post Action to ship the captured event logs via our HTTP Action to our remote server. Option Usage URL Required, URL of the remote server Method Required, e.g., GET, POST Headers Optional, custom headers to send Timeout Optional, custom timeout for HTTP call Bodyfile Optional, input file for HTTP post body To run Postee in the container, we can invoke the Postee Docker container: docker run --rm --name=postee \\ -v <path-to-cfg>:/config/cfg-actions.yaml \\ -e POSTEE_CFG=/config/cfg-actions.yaml \\ -e POSTEE_HTTP=0.0.0.0:8084 \\ -e POSTEE_HTTPS=0.0.0.0:8444 \\ -p 8084:8084 -p 8444:8444 aquasecurity/postee:latest","title":"HTTP Action"},{"location":"examples/","text":"Here are some Postee configuration samples to showcase a variety of use cases. Forward all \"Block\" audit events name : myserver aqua-server : https://myserver.com max-db-size : 1000MB delete-old-data : 100 db-verify-interval : 1 routes : - name : team-drift input : input.level = \"block\" actions : [ my-teams ] template : raw-html actions : - name : my-teams type : teams enable : true url : https://outlook.office.com/webhook/<replace> templates : - name : raw-html rego-package : postee.rawmessage.html Forward Critical vulnerabilities # This example will forward events of images with critical vulnerabilities to MS Teams. # Note that duplicate events of same image will be ignored for 30 days. name : myserver aqua-server : https://myserver.com max-db-size : 1000MB delete-old-data : 100 db-verify-interval : 1 routes : - name : team-critical-vul input : input.vulnerability_summary.critical > 0 actions : [ my-teams ] template : raw-html plugins : unique-message-props : [ \"digest\" , \"image\" , \"registry\" , \"vulnerability_summary.high\" , \"vulnerability_summary.medium\" , \"vulnerability_summary_low\" ] unique-message-timeout : 30d actions : - name : my-teams type : teams enable : true url : https://outlook.office.com/webhook/<replace> templates : - name : raw-html rego-package : postee.rawmessage.html Forward Drift events # This example will forward events of Drift Prevention to MS Teams. name : myserver aqua-server : https://myserver.com max-db-size : 1000MB # Max size of DB. <numbers><unit suffix> pattern is used, such as \"300MB\" or \"1GB\". If empty or 0 then unlimited delete-old-data : 100 # delete data older than N day(s). If empty then we do not delete. db-verify-interval : 1 # hours. an Interval between tests of DB. Default: 1 hour routes : - name : team-drift input : contains(input.control, \"Drift\") actions : [ my-teams ] template : raw-html actions : - name : my-teams type : teams enable : true url : https://outlook.office.com/webhook/<replace> templates : - name : raw-html # Raw message json rego-package : postee.rawmessage.html # HTLM template REGO package Add Kubernetes Labels and Annotations name : tenant aqua-server : max-db-size : 1000MB db-verify-interval : 1 routes : - name : stdout actions : [ stdout ] template : raw-json - name : actions-route input : contains(input.SigMetadata.ID, \"TRC-2\") actions : [ my-k8s ] template : raw-json templates : - name : raw-json rego-package : postee.rawmessage.json actions : - name : stdout type : stdout enable : true - name : my-k8s type : kubernetes enable : true kube-namespace : \"default\" kube-config-file : \"/path/to/kubeconfig\" kube-label-selector : \"app=nginx-app\" kube-actions : labels : foo-label : \"bar-value\" bar-label : event.input.SigMetadata.ID annotations : foo-annotation : \"bar-value\" bar-annotation : event.input.SigMetadata.ID Run ad-hoc docker image name : tenant aqua-server : max-db-size : 1000MB db-verify-interval : 1 routes : - name : stdout actions : [ stdout ] template : raw-json - name : actions-route input : contains(input.SigMetadata.ID, \"TRC-2\") actions : [ stop-vulnerable-pod ] template : raw-json templates : - name : raw-json rego-package : postee.rawmessage.json actions : - name : stdout type : stdout enable : true - name : stop-vulnerable-pod type : docker enable : true docker-image-name : \"bitnami/kubectl:latest\" docker-cmd : [ \"delete\" , \"pod\" , event.input.SigMetadata.hostname ] docker-network : \"host\" docker-volume-mounts : \"path/to/.kube/config\" : \"/.kube/config\" Collect and send logs name : tenant aqua-server : localhost max-db-size : 1000MB db-verify-interval : 1 routes : - name : stdout actions : [ stdout ] template : raw-json - name : actions-route input : contains(input.SigMetadata.ID, \"TRC-2\") serialize-actions : true actions : [ my-exec , my-http-post-file , my-http-post-content ] template : raw-json templates : - name : raw-json rego-package : postee.rawmessage.json actions : - name : stdout type : stdout enable : true - name : my-exec type : exec enable : true env : [ \"MY_ENV_VAR=foo_bar_baz\" , \"MY_KEY=secret\" ] exec-script : | #!/bin/sh echo $POSTEE_EVENT >> /tmp/postee.event.logs - name : my-http-post-file type : http enable : true url : \"https://my-fancy-url.com\" method : POST body-file : /tmp/postee.event.logs - name : my-http-post-content type : http enable : true url : \"https://my-fancy-url.com\" method : POST headers : \"Foo\" : [ \"bar\" ] \"Haz\" : [ \"baz\" ] timeout : 10s body-content : | This is an example of a inline body Event ID : event.input.Signature.ID","title":"Simple Examples"},{"location":"install/","text":"To run Postee you will first need to configure the Postee Configuration File , which contains all the message routing logic. After the configuration file is ready, you can run the official Postee container image: aquasec/postee:latest , or compile it from source. There are different options to mount your customize configuration file to Postee - if running as a Docker container, then you simply mount the configuration files as a volume mount. If running as a Kubernetes deployment, you will need to mount it as a ConfigMap. See the below usage examples for how to run Postee on different scenarios. After Postee will run, it will expose two endpoints, HTTP and HTTPS. You can send your JSON messages to these endpoints, where they will be delivered to their target system based on the defined rules. Docker \u00b6 To run Postee as a Docker container, you mount the cfg.yaml to '/config/cfg.yaml' path in the Postee container. docker run -d --name = postee -v /<path to configuration file>/cfg.yaml:/config/cfg.yaml \\ -e POSTEE_CFG = /config/cfg.yaml -e POSTEE_HTTP = 0 .0.0.0:8084 -e POSTEE_HTTPS = 0 .0.0.0:8444 \\ -p 8084 :8084 -p 8444 :8444 aquasec/postee:latest Kubernetes \u00b6 When running Postee on Kubernetes, the configuration file is passed as a ConfigMap that is mounted to the Postee pod. Cloud Providers \u00b6 kubectl create -f https://raw.githubusercontent.com/aquasecurity/postee/main/deploy/kubernetes/postee.yaml Using HostPath \u00b6 kubectl create -f https://raw.githubusercontent.com/aquasecurity/postee/main/deploy/kubernetes/hostPath/postee-pv.yaml To edit the default Postee-UI user kubectl -n postee set env deployment/my-posteeui -e POSTEE_ADMIN_USER=testabc -e POSTEE_ADMIN_PASSWORD=password The Postee endpoints http://postee-svc.default.svc.cluster.local:8082 https://postee-svc.default.svc.cluster.local:8445 The Postee-UI endpoint http://postee-ui-svc.default.svc.cluster.local:8000 Helm \u00b6 When running Postee on Kubernetes, the configuration file is passed as a ConfigMap that is mounted to the Postee pod. This chart bootstraps a Postee deployment on a Kubernetes cluster using the Helm package manager . Prerequisites \u00b6 Kubernetes 1.17+ Helm 3+ Test the Chart Repository \u00b6 cd deploy/helm helm install my-postee -n postee --dry-run --set-file applicationConfigPath = \"../../cfg.yaml\" ./postee Installing the Chart from the Source Code \u00b6 cd deploy/helm helm install app --create-namespace -n postee ./postee Installing from the the Aqua Chart Repository \u00b6 Let's add the Helm chart and deploy Postee executing: helm repo add aquasecurity https://aquasecurity.github.io/helm-charts/ helm repo update helm search repo postee helm install app --create-namespace -n postee aquasecurity/postee Check that all the pods are in Running state: kubectl get pods -n postee We check the logs: kubectl logs deployment/my-posteeui -n postee | head kubectl logs statefulsets/my-postee -n postee | head Delete Chart \u00b6 helm -n postee delete my-postee From Source \u00b6 Clone and build the project: git clone git@github.com:aquasecurity/postee.git make build After that, modify the cfg.yaml file and set the 'POSTEE_CFG' environment variable to point to it. export POSTEE_CFG = <path to cfg.yaml> ./bin/postee","title":"Installation"},{"location":"install/#docker","text":"To run Postee as a Docker container, you mount the cfg.yaml to '/config/cfg.yaml' path in the Postee container. docker run -d --name = postee -v /<path to configuration file>/cfg.yaml:/config/cfg.yaml \\ -e POSTEE_CFG = /config/cfg.yaml -e POSTEE_HTTP = 0 .0.0.0:8084 -e POSTEE_HTTPS = 0 .0.0.0:8444 \\ -p 8084 :8084 -p 8444 :8444 aquasec/postee:latest","title":"Docker"},{"location":"install/#kubernetes","text":"When running Postee on Kubernetes, the configuration file is passed as a ConfigMap that is mounted to the Postee pod.","title":"Kubernetes"},{"location":"install/#cloud-providers","text":"kubectl create -f https://raw.githubusercontent.com/aquasecurity/postee/main/deploy/kubernetes/postee.yaml","title":"Cloud Providers"},{"location":"install/#using-hostpath","text":"kubectl create -f https://raw.githubusercontent.com/aquasecurity/postee/main/deploy/kubernetes/hostPath/postee-pv.yaml To edit the default Postee-UI user kubectl -n postee set env deployment/my-posteeui -e POSTEE_ADMIN_USER=testabc -e POSTEE_ADMIN_PASSWORD=password The Postee endpoints http://postee-svc.default.svc.cluster.local:8082 https://postee-svc.default.svc.cluster.local:8445 The Postee-UI endpoint http://postee-ui-svc.default.svc.cluster.local:8000","title":"Using HostPath"},{"location":"install/#helm","text":"When running Postee on Kubernetes, the configuration file is passed as a ConfigMap that is mounted to the Postee pod. This chart bootstraps a Postee deployment on a Kubernetes cluster using the Helm package manager .","title":"Helm"},{"location":"install/#prerequisites","text":"Kubernetes 1.17+ Helm 3+","title":"Prerequisites"},{"location":"install/#test-the-chart-repository","text":"cd deploy/helm helm install my-postee -n postee --dry-run --set-file applicationConfigPath = \"../../cfg.yaml\" ./postee","title":"Test the Chart Repository"},{"location":"install/#installing-the-chart-from-the-source-code","text":"cd deploy/helm helm install app --create-namespace -n postee ./postee","title":"Installing the Chart from the Source Code"},{"location":"install/#installing-from-the-the-aqua-chart-repository","text":"Let's add the Helm chart and deploy Postee executing: helm repo add aquasecurity https://aquasecurity.github.io/helm-charts/ helm repo update helm search repo postee helm install app --create-namespace -n postee aquasecurity/postee Check that all the pods are in Running state: kubectl get pods -n postee We check the logs: kubectl logs deployment/my-posteeui -n postee | head kubectl logs statefulsets/my-postee -n postee | head","title":"Installing from the the Aqua Chart Repository"},{"location":"install/#delete-chart","text":"helm -n postee delete my-postee","title":"Delete Chart"},{"location":"install/#from-source","text":"Clone and build the project: git clone git@github.com:aquasecurity/postee.git make build After that, modify the cfg.yaml file and set the 'POSTEE_CFG' environment variable to point to it. export POSTEE_CFG = <path to cfg.yaml> ./bin/postee","title":"From Source"},{"location":"routes/","text":"A route is used to control message flows. Each route includes the input message condition, the template that should be used to format the message, and the action(s) that the message should be delivered to. The most important part of a route is the input definition using the Rego language to define what are the conditions for an incoming message to be handled by a certain route. Tip See the complete Rego Language in OPA-reference After defining the route's input condition, what is left is to define the template that will be used to format the input message, and the action that formatted message will be sent to. The below table describes the fields to define a route: Key Description Possible Values Example name Unique name of route string teams-vul-route input A Rego rule to match against incoming messages. If there is a match then this route will be chosen for the incoming message Rego language statements contains(input.message,\"alpine\") input-files One or more files with Rego rules Set of Rego language files [\"Policy-Registry.rego\", \"Policy-Min-Vulnerability.rego\"] actions One or more actions that are defined in the \"actions\" section Set of action names. At least one element is required [\"my-slack\", \"my-email\"]. serialize-actions Serialize the list of actions true, false(default) true template A template that is defined in the \"template\" section any template name raw-html The rego-filters folder contains examples of policy related functions. You can use the examples. To do this, you need to change the input data in the arrays of rego files and fill in the config file. If you want to use an other folder, set the 'REGO_FILTERS_PATH' environment variable to point to it. When using 2 or more files, they will be combined by \"OR\". To combine policy related functions by \"AND\", use the Policy-Related-Features.rego file, change the input data, and fill in the required function in allow. allow{ PermitImageNames PermitMinVulnerability } If you are using your own rego files, then the package field should be \"postee\" and the result should be in the allow function: package postee your_function{...} # 0 or more your functions allow { your_function } For example, the following input definition will match JSON messages that have 'image.name' field with value that contains the string 'alpine': input: contains(input.image,\"alpine\") Another example using regular expression: input: regex.match(\"alp:*\", input.image) You can create more complex input definitions using the Rego language. For example, the following input definition will match JSON messages that have 'image.name' field with value 'alpine' and that their registry is 'Docker Hub' and they have a critical vulnerability. input: | contains(input.image,\"alpine\") contains(input.registry, \"Docker Hub\") input.vulnerability_summary.critical>0 Postee Route Configuration \u00b6 You could use Postee with any json. See the following example receiving json events: Route All Messages \u00b6 To create a route that matches all messages, simply use the following: routes: - name: catch-all input: input ... Route Drift Prevention Messages \u00b6 To create a route that matches only messages that originated from a \"Drift Prevention\" event, use the following: routes: - name: catch-drift input: contains(input.control, \"Drift\") ... Route Tracee Message \u00b6 The following input JSON message is from Tracee . Set input property of route to: contains(input.SigMetadata.ID,\"TRC-\") to limit the route to handle Tracee messages only In the section rego-templates have rego templates samples to use with Tracee: - tracee-html.rego - tracee-slack.rego Plugins \u00b6 'Plugins' section contains configuration for useful Postee features. Key Description Possible Values Example aggregate-message-number Number of messages to aggregate into one message. any integer value 10 aggregate-message-timeout number of seconds, minutes, hours to aggregate Maximum is 24 hours Xs or Xm or Xh 1h unique-message-props Optional. Comma separated list of properties which uniquely identifies an event message. If message with same property values is received more than once, consequitive messages will be ignored. Array of properties that their value uniquely identifies a message To avoid duplicate scanning messages you can use the following properties: unique-message-props: [\"digest\",\"image\",\"registry\", \"vulnerability_summary.high\", \"vulnerability_summary.medium\", \"vulnerability_summary.low\"] unique-message-timeout Optional. Used along with unique-message-props , has no effect if unique props are not specified. Number of seconds/minutes/hours/days before expiring of a message. Expired messages are removed from db. If option is empty message is never deleted 1d","title":"Routes"},{"location":"routes/#postee-route-configuration","text":"You could use Postee with any json. See the following example receiving json events:","title":"Postee Route Configuration"},{"location":"routes/#route-all-messages","text":"To create a route that matches all messages, simply use the following: routes: - name: catch-all input: input ...","title":"Route All Messages"},{"location":"routes/#route-drift-prevention-messages","text":"To create a route that matches only messages that originated from a \"Drift Prevention\" event, use the following: routes: - name: catch-drift input: contains(input.control, \"Drift\") ...","title":"Route Drift Prevention Messages"},{"location":"routes/#route-tracee-message","text":"The following input JSON message is from Tracee . Set input property of route to: contains(input.SigMetadata.ID,\"TRC-\") to limit the route to handle Tracee messages only In the section rego-templates have rego templates samples to use with Tracee: - tracee-html.rego - tracee-slack.rego","title":"Route Tracee Message"},{"location":"routes/#plugins","text":"'Plugins' section contains configuration for useful Postee features. Key Description Possible Values Example aggregate-message-number Number of messages to aggregate into one message. any integer value 10 aggregate-message-timeout number of seconds, minutes, hours to aggregate Maximum is 24 hours Xs or Xm or Xh 1h unique-message-props Optional. Comma separated list of properties which uniquely identifies an event message. If message with same property values is received more than once, consequitive messages will be ignored. Array of properties that their value uniquely identifies a message To avoid duplicate scanning messages you can use the following properties: unique-message-props: [\"digest\",\"image\",\"registry\", \"vulnerability_summary.high\", \"vulnerability_summary.medium\", \"vulnerability_summary.low\"] unique-message-timeout Optional. Used along with unique-message-props , has no effect if unique props are not specified. Number of seconds/minutes/hours/days before expiring of a message. Expired messages are removed from db. If option is empty message is never deleted 1d","title":"Plugins"},{"location":"settings/","text":"General settings are specified at the root level of cfg.yaml. They include general configuration that applies to the Postee application. Key Description Possible Values Example Value aqua-server Aqua Platform URL. This is used for some of the integrations to will include a link to the Aqua UI Aqua Platform valid URL https://server.my.aqua db-verify-interval Specify time interval (in hours) for Postee to perform database cleanup jobs. Default: 1 hour any integer value 1 max-db-size The maximum size of Postee database (in B, KB, MB or GB). Once reached to size limit, Postee will delete old cached messages. If empty then Postee database will have unlimited size any integer value with a unit siffux 200kb, 1000 MB, 1Gb","title":"General"},{"location":"templates/","text":"Templates are used to format input messages before sending them to the action. For example - before sending a message to Microsoft Teams there is a need to format the input JSON into an HTML. This is done using a template. Each template has a name field, which is used by the route to assign the template to input and output. Tip Use the default Legacy template \"html\" for general output In addition to name, a template will have one of the 4 below keys: Key Description Example rego-package Postee loads bundle of templates from rego-templates folder. This folder includes several templates shipped with Postee, which can be used out of the box. You can add additional custom templates by placing Rego file under the 'rego-templates' directory. postee.vuls.html body Specify inline template. Relative small templates can be added to config directly input url Load from url. Rego template can be loaded from url. http://myserver.com/rego.txt legacy-scan-renderer Legacy templates are introduced to support Postee V1 renderers. Available values are \"jira\", \"slack\", \"html\". \"jira\" should be used for jira integration, \"slack\" is for slack and \"html\" is for everything else. html Tip Pre made examples for templates can be found here Customizing Templates \u00b6 It is possible to customize templates and even write new ones from scratch. Follow the guide in our advanced section here: Customizing Templates Troubleshooting of Rego Templates \u00b6 Rego templates provide very flexible way for transformation of received json. You can convert received information to html or json. On the flip side sometimes it may be difficult to find root cause of issue (if you run into any while configuring custom template). Postee application doesn't have many options to provide detailed error message. Very often if something goes wrong then 'result' property is omitted from rego evaluation result and it causes errors like: 2021/07/23 18:27:31 Error while evaluating input: property result is not found So here are details to help with troubleshooting: Required tools \u00b6 opa - tool to evaluate OPA queries directly jq - flexible command-line JSON processor. Evaluate template to build html \u00b6 Here is example of command to evaluate rego: opa eval data.postee.vuls.html.result --data vuls-html.rego --data common/common.rego --input <path to input json> | jq -r .result[0].expressions[0].value The example above should be started in rego-templates folder and evaluates default html template shipped with postee. First opa argument is query. Three parts are used to build query data . <your rego package> . result . You may want to evaluate title property. In this case query would be: data . <your rego package> . title Evaluate template to build json \u00b6 cd rego-templates opa eval data.postee.vuls.slack.result --data vuls-slack.rego --data common/common.rego --input <path to input json> | jq .result[0].expressions[0].value The command above is similar to html case but jq is used a bit different way.","title":"Templates"},{"location":"templates/#customizing-templates","text":"It is possible to customize templates and even write new ones from scratch. Follow the guide in our advanced section here: Customizing Templates","title":"Customizing Templates"},{"location":"templates/#troubleshooting-of-rego-templates","text":"Rego templates provide very flexible way for transformation of received json. You can convert received information to html or json. On the flip side sometimes it may be difficult to find root cause of issue (if you run into any while configuring custom template). Postee application doesn't have many options to provide detailed error message. Very often if something goes wrong then 'result' property is omitted from rego evaluation result and it causes errors like: 2021/07/23 18:27:31 Error while evaluating input: property result is not found So here are details to help with troubleshooting:","title":"Troubleshooting of Rego Templates"},{"location":"templates/#required-tools","text":"opa - tool to evaluate OPA queries directly jq - flexible command-line JSON processor.","title":"Required tools"},{"location":"templates/#evaluate-template-to-build-html","text":"Here is example of command to evaluate rego: opa eval data.postee.vuls.html.result --data vuls-html.rego --data common/common.rego --input <path to input json> | jq -r .result[0].expressions[0].value The example above should be started in rego-templates folder and evaluates default html template shipped with postee. First opa argument is query. Three parts are used to build query data . <your rego package> . result . You may want to evaluate title property. In this case query would be: data . <your rego package> . title","title":"Evaluate template to build html"},{"location":"templates/#evaluate-template-to-build-json","text":"cd rego-templates opa eval data.postee.vuls.slack.result --data vuls-slack.rego --data common/common.rego --input <path to input json> | jq .result[0].expressions[0].value The command above is similar to html case but jq is used a bit different way.","title":"Evaluate template to build json"},{"location":"troubleshooting-of-rego-templates/","text":"","title":"Troubleshooting of rego templates"},{"location":"ui/","text":"Postee provides a simple Web UI to simplify the configuration management. Configure and run Postee UI application \u00b6 Requirements \u00b6 Postee Admin application shares location of cfg.yaml with main webhook app, also Bolt database needs to be in folder which is available for both apps. Danger If application config is submitted by UI app then all yaml comments are removed. So if comments are important please make backup of config yaml. Kubernetes for Postee UI application \u00b6 The manifest is here . It will expose a service postee-ui-svc in the port 8000 . http://postee-ui.default.svc.cluster.local:8000 Docker Image for Postee UI application \u00b6 Dockerfile to build image for UI app is here Orchestration example (Docker Compose) \u00b6 There is an example of docker-compose.yml that can be used to simplify deploying of both app. Notice that two shared volumes are used. One is for Bolt db and second to store app config. To start apps use: docker-compose up . Environment variables \u00b6 Name Description Default value POSTEE_UI_CFG Path to app config required, no default value POSTEE_UI_PORT Port to use with UI app 8090 POSTEE_UI_UPDATE_URL Url of webhook application required POSTEE_ADMIN_USER Admin account name admin POSTEE_ADMIN_PASSWORD Admin account password admin","title":"Postee UI"},{"location":"ui/#configure-and-run-postee-ui-application","text":"","title":"Configure and run Postee UI application"},{"location":"ui/#requirements","text":"Postee Admin application shares location of cfg.yaml with main webhook app, also Bolt database needs to be in folder which is available for both apps. Danger If application config is submitted by UI app then all yaml comments are removed. So if comments are important please make backup of config yaml.","title":"Requirements"},{"location":"ui/#kubernetes-for-postee-ui-application","text":"The manifest is here . It will expose a service postee-ui-svc in the port 8000 . http://postee-ui.default.svc.cluster.local:8000","title":"Kubernetes for Postee UI application"},{"location":"ui/#docker-image-for-postee-ui-application","text":"Dockerfile to build image for UI app is here","title":"Docker Image for Postee UI application"},{"location":"ui/#orchestration-example-docker-compose","text":"There is an example of docker-compose.yml that can be used to simplify deploying of both app. Notice that two shared volumes are used. One is for Bolt db and second to store app config. To start apps use: docker-compose up .","title":"Orchestration example (Docker Compose)"},{"location":"ui/#environment-variables","text":"Name Description Default value POSTEE_UI_CFG Path to app config required, no default value POSTEE_UI_PORT Port to use with UI app 8090 POSTEE_UI_UPDATE_URL Url of webhook application required POSTEE_ADMIN_USER Admin account name admin POSTEE_ADMIN_PASSWORD Admin account password admin","title":"Environment variables"},{"location":"actions/actions/","text":"Postee Actions \u00b6 Motivation \u00b6 Proper alert management can help security practitioners make informed decisions about their codebase. However, security alerts can cause fatigue if acting on them isn\u2019t possible. Postee, an open source security alert management tool, helps mitigate some of those concerns. It enables teams to define routes and rules by which alerts are handled and redirected to User Stories \u00b6 In a typical Postee setup, users can configure the tool to receive events from a variety of sources over a webhook. This allows for ease of use in existing environments. Furthermore, users can configure Postee to process these incoming events and, based on logic defined via Rego rules, send them to different actions. As a, Postee User - I want , to be able to remove a vulnerable image from my cluster upon a Trivy scan So that , I can keep such images unavailable for deployment. I want , to ship Tracee security notification logs from my node when events are detected So that , I can build a timelog for forensics purposes. I want , to be able to add labels to my deployments when Starboard detects a vulnerable image in my cluster So that , I can effectively tag my resources. Configuring Postee Actions \u00b6 In this README, we\u2019ll walk through a scenario in which a user wants to act on a security event received from Tracee, an open source runtime security tool. In this scenario, the user will set up the Postee Exec Action to save logs for forensic purposes and then use the Postee HTTP Action to ship the saved logs to a remote server. In this case, the incoming security event from Tracee is received by Postee and evaluated by the following route YAML definition: As seen above, the route has a Rego rule that evaluates the input to contain a certain signature ID, TRC-2, which represents anti-debugging activity. In addition, if the input is matched, the output is triggered. Exec Action \u00b6 In this case, we call the Exec Action first and then the HTTP Action. They are defined as the following: The Exec Action can take in the following parameters: Option Usage env Optional, custom environment variables to be exposed in the shell of the executing script input-file Required, custom shell script to executed exec-script Required, inline shell script executed The Exec Action also internally exposes the $POSTEE_EVENT environment variable with the input event that triggered the action. This can be helpful in situations where the event itself contains useful information. Below is an example of using $POSTEE_EVENT . It uses the inline exec-script script: As you can see, we capture the incoming Postee event and write this event to the Tracee event log for forensic purposes. HTTP Action \u00b6 Finally, we can configure the Postee HTTP Post Action to ship the captured event logs via our HTTP Action to our remote server. Option Usage URL Required, URL of the remote server Method Required, e.g., GET, POST Headers Optional, custom headers to send Timeout Optional, custom timeout for HTTP call Bodyfile Optional, input file for HTTP post body To run Postee in the container, we can invoke the Postee Docker container: docker run --rm --name=postee \\ -v <path-to-cfg>:/config/cfg-actions.yaml \\ -e POSTEE_CFG=/config/cfg-actions.yaml \\ -e POSTEE_HTTP=0.0.0.0:8084 \\ -e POSTEE_HTTPS=0.0.0.0:8444 \\ -p 8084:8084 -p 8444:8444 aquasecurity/postee:latest Kubernetes Action \u00b6 In addition to the Exec and HTTP actions, we have also implemented a Kubernetes action that today can add labels and annotations to pods. It can be used as follows: Option Usage kube-namespace Required. Kubernetes namespace to use. kube-config-file Required. Path to .kubeconfig file kube-label-selector Required, if specifying labels or annotations. kube-actions Optional, key-value pair of labels and annotations Labels must be added via \"labels\" key and Annotations via \"annotations\". Docker Action \u00b6 We have also added a Docker Action, that can help you run docker images as an action within a container. Option Usage docker-image-name Required. Image name of the docker image. docker-cmd Required. Command to run inside the docker image. docker-env Optional. Environment variables to set in the container. docker-network Optional. Connect the action container to the specified network. docker-volume-mounts Optional*. Volume mounts present inside the container. * If you have specified volume mounts, you also need to pass them through into the postee docker container Note \u00b6 When running Postee in a Docker container, it is required to mount the Docker socket within the Postee container to be able to spin up Docker Action container instances. This can be done as follows: docker run --rm --name=postee --group-add $(stat -c '%g' /var/run/docker.sock) -v /var/run/docker.sock:/var/run/docker.sock -v /path/to/cfg.yaml:/config/cfg.yaml -e POSTEE_CFG=/config/cfg.yaml -e POSTEE_HTTP=0.0.0.0:8084 -e POSTEE_HTTPS=0.0.0.0:8444 -p 8084:8084 -p 8444:8444 aquasecurity/postee:latest If you have specified volume mounts for a docker container and use Postee in a docker container as well, remember to mount them within the Postee container as well: docker run --rm --name=postee --group-add $(stat -c '%g' /var/run/docker.sock) -v /var/run/docker.sock:/var/run/docker.sock -v /path/to/cfg.yaml:/config/cfg.yaml -v /my/custom/volume:/my/custom/volume -e POSTEE_CFG=/config/cfg.yaml -e POSTEE_HTTP=0.0.0.0:8084 -e POSTEE_HTTPS=0.0.0.0:8444 -p 8084:8084 -p 8444:8444 aquasecurity/postee:latest","title":"Postee Actions"},{"location":"actions/actions/#postee-actions","text":"","title":"Postee Actions"},{"location":"actions/actions/#motivation","text":"Proper alert management can help security practitioners make informed decisions about their codebase. However, security alerts can cause fatigue if acting on them isn\u2019t possible. Postee, an open source security alert management tool, helps mitigate some of those concerns. It enables teams to define routes and rules by which alerts are handled and redirected to","title":"Motivation"},{"location":"actions/actions/#user-stories","text":"In a typical Postee setup, users can configure the tool to receive events from a variety of sources over a webhook. This allows for ease of use in existing environments. Furthermore, users can configure Postee to process these incoming events and, based on logic defined via Rego rules, send them to different actions. As a, Postee User - I want , to be able to remove a vulnerable image from my cluster upon a Trivy scan So that , I can keep such images unavailable for deployment. I want , to ship Tracee security notification logs from my node when events are detected So that , I can build a timelog for forensics purposes. I want , to be able to add labels to my deployments when Starboard detects a vulnerable image in my cluster So that , I can effectively tag my resources.","title":"User Stories"},{"location":"actions/actions/#configuring-postee-actions","text":"In this README, we\u2019ll walk through a scenario in which a user wants to act on a security event received from Tracee, an open source runtime security tool. In this scenario, the user will set up the Postee Exec Action to save logs for forensic purposes and then use the Postee HTTP Action to ship the saved logs to a remote server. In this case, the incoming security event from Tracee is received by Postee and evaluated by the following route YAML definition: As seen above, the route has a Rego rule that evaluates the input to contain a certain signature ID, TRC-2, which represents anti-debugging activity. In addition, if the input is matched, the output is triggered.","title":"Configuring Postee Actions"},{"location":"actions/actions/#exec-action","text":"In this case, we call the Exec Action first and then the HTTP Action. They are defined as the following: The Exec Action can take in the following parameters: Option Usage env Optional, custom environment variables to be exposed in the shell of the executing script input-file Required, custom shell script to executed exec-script Required, inline shell script executed The Exec Action also internally exposes the $POSTEE_EVENT environment variable with the input event that triggered the action. This can be helpful in situations where the event itself contains useful information. Below is an example of using $POSTEE_EVENT . It uses the inline exec-script script: As you can see, we capture the incoming Postee event and write this event to the Tracee event log for forensic purposes.","title":"Exec Action"},{"location":"actions/actions/#http-action","text":"Finally, we can configure the Postee HTTP Post Action to ship the captured event logs via our HTTP Action to our remote server. Option Usage URL Required, URL of the remote server Method Required, e.g., GET, POST Headers Optional, custom headers to send Timeout Optional, custom timeout for HTTP call Bodyfile Optional, input file for HTTP post body To run Postee in the container, we can invoke the Postee Docker container: docker run --rm --name=postee \\ -v <path-to-cfg>:/config/cfg-actions.yaml \\ -e POSTEE_CFG=/config/cfg-actions.yaml \\ -e POSTEE_HTTP=0.0.0.0:8084 \\ -e POSTEE_HTTPS=0.0.0.0:8444 \\ -p 8084:8084 -p 8444:8444 aquasecurity/postee:latest","title":"HTTP Action"},{"location":"actions/actions/#kubernetes-action","text":"In addition to the Exec and HTTP actions, we have also implemented a Kubernetes action that today can add labels and annotations to pods. It can be used as follows: Option Usage kube-namespace Required. Kubernetes namespace to use. kube-config-file Required. Path to .kubeconfig file kube-label-selector Required, if specifying labels or annotations. kube-actions Optional, key-value pair of labels and annotations Labels must be added via \"labels\" key and Annotations via \"annotations\".","title":"Kubernetes Action"},{"location":"actions/actions/#docker-action","text":"We have also added a Docker Action, that can help you run docker images as an action within a container. Option Usage docker-image-name Required. Image name of the docker image. docker-cmd Required. Command to run inside the docker image. docker-env Optional. Environment variables to set in the container. docker-network Optional. Connect the action container to the specified network. docker-volume-mounts Optional*. Volume mounts present inside the container. * If you have specified volume mounts, you also need to pass them through into the postee docker container","title":"Docker Action"},{"location":"actions/actions/#note","text":"When running Postee in a Docker container, it is required to mount the Docker socket within the Postee container to be able to spin up Docker Action container instances. This can be done as follows: docker run --rm --name=postee --group-add $(stat -c '%g' /var/run/docker.sock) -v /var/run/docker.sock:/var/run/docker.sock -v /path/to/cfg.yaml:/config/cfg.yaml -e POSTEE_CFG=/config/cfg.yaml -e POSTEE_HTTP=0.0.0.0:8084 -e POSTEE_HTTPS=0.0.0.0:8444 -p 8084:8084 -p 8444:8444 aquasecurity/postee:latest If you have specified volume mounts for a docker container and use Postee in a docker container as well, remember to mount them within the Postee container as well: docker run --rm --name=postee --group-add $(stat -c '%g' /var/run/docker.sock) -v /var/run/docker.sock:/var/run/docker.sock -v /path/to/cfg.yaml:/config/cfg.yaml -v /my/custom/volume:/my/custom/volume -e POSTEE_CFG=/config/cfg.yaml -e POSTEE_HTTP=0.0.0.0:8084 -e POSTEE_HTTPS=0.0.0.0:8444 -p 8084:8084 -p 8444:8444 aquasecurity/postee:latest","title":"Note"},{"location":"blueprints/external-healthcheck/","text":"Distributed Service Healthcheck \u00b6 Introduction \u00b6 In this walkthrough, we will setup a globally distributed healthcheck for a service that we expect to be accessible from anywhere. This walkthrough will combine Postee Actions and AWS Lambda to accomplish this. Scenario \u00b6 A DevOps operator gets paged about a service that they maintain. This page turns out to be flaky and non-actionable. In order to avoid operator fatigue, we can confirm the correctness of the page by triggering several healthchecks upon the notification of such an event. These healthchecks are performed externally via Lambda functions spread across different regions. By performing such globally distributed checks, the operator can be rest assured of the accuracy of any failures and in addition narrow out the scope of the problem. Sample Configs \u00b6 In this case a sample configuration for the components can be described as follows: Postee Config \u00b6 Postee Actions dispatches calls via the HTTP Action to 3 different AWS Lambda URLs. These requests are performed in parallel. In addition, the operator is performed of the trigger and notified via a Slack message. routes : - name : actions-route input : contains(input.ServiceURL.Reachable, \"false\") actions : [ send-slack-message , eu-check , apac-check , na-check ] # Outputs are target services that should consume the messages actions : - name : send-slack-messsage type : slack enable : true url : https://hooks.slack.com/services/TAAAA/BBB/<key> - name : eu-check type : http enable : true url : \"https://<uuid-func>.lambda-url.<aws-region>.on.aws/\" method : POST - name : apac-check type : http enable : true url : \"https://<uuid-func>.lambda-url.<aws-region>.on.aws/\" method : POST - name : na-check type : http enable : true url : \"https://<uuid-func>.lambda-url.<aws-region>.on.aws/\" method : POST Lambda Config \u00b6 import os from datetime import datetime from urllib.request import Request , urlopen SITE = \"https://www.my-highly-available-website.com\" EXPECTED = \"Text I expect to find\" def validate ( res ): return EXPECTED in res def lambda_handler ( event , context ): timeNow = datetime . today () . strftime ( '%Y-%m- %d -%H:%M:%S' ) print ( 'Checking {} at {} ...' . format ( SITE , timeNow )) try : req = Request ( SITE , headers = { 'User-Agent' : 'AWS Lambda' }) if not validate ( str ( urlopen ( req ) . read ())): raise Exception ( 'Validation failed' ) except : print ( 'Check failed!' ) raise else : print ( 'Check passed!' ) return ( 'aquasec.com is up! at {} ' . format ( timeNow )) finally : print ( 'Check complete at {} ' . format ( str ( datetime . now ()))) Inspired by: https://github.com/amazon-archives/serverless-app-examples/blob/master/python/lambda-canary/lambda_function.py","title":"External Healthcheck"},{"location":"blueprints/external-healthcheck/#distributed-service-healthcheck","text":"","title":"Distributed Service Healthcheck"},{"location":"blueprints/external-healthcheck/#introduction","text":"In this walkthrough, we will setup a globally distributed healthcheck for a service that we expect to be accessible from anywhere. This walkthrough will combine Postee Actions and AWS Lambda to accomplish this.","title":"Introduction"},{"location":"blueprints/external-healthcheck/#scenario","text":"A DevOps operator gets paged about a service that they maintain. This page turns out to be flaky and non-actionable. In order to avoid operator fatigue, we can confirm the correctness of the page by triggering several healthchecks upon the notification of such an event. These healthchecks are performed externally via Lambda functions spread across different regions. By performing such globally distributed checks, the operator can be rest assured of the accuracy of any failures and in addition narrow out the scope of the problem.","title":"Scenario"},{"location":"blueprints/external-healthcheck/#sample-configs","text":"In this case a sample configuration for the components can be described as follows:","title":"Sample Configs"},{"location":"blueprints/external-healthcheck/#postee-config","text":"Postee Actions dispatches calls via the HTTP Action to 3 different AWS Lambda URLs. These requests are performed in parallel. In addition, the operator is performed of the trigger and notified via a Slack message. routes : - name : actions-route input : contains(input.ServiceURL.Reachable, \"false\") actions : [ send-slack-message , eu-check , apac-check , na-check ] # Outputs are target services that should consume the messages actions : - name : send-slack-messsage type : slack enable : true url : https://hooks.slack.com/services/TAAAA/BBB/<key> - name : eu-check type : http enable : true url : \"https://<uuid-func>.lambda-url.<aws-region>.on.aws/\" method : POST - name : apac-check type : http enable : true url : \"https://<uuid-func>.lambda-url.<aws-region>.on.aws/\" method : POST - name : na-check type : http enable : true url : \"https://<uuid-func>.lambda-url.<aws-region>.on.aws/\" method : POST","title":"Postee Config"},{"location":"blueprints/external-healthcheck/#lambda-config","text":"import os from datetime import datetime from urllib.request import Request , urlopen SITE = \"https://www.my-highly-available-website.com\" EXPECTED = \"Text I expect to find\" def validate ( res ): return EXPECTED in res def lambda_handler ( event , context ): timeNow = datetime . today () . strftime ( '%Y-%m- %d -%H:%M:%S' ) print ( 'Checking {} at {} ...' . format ( SITE , timeNow )) try : req = Request ( SITE , headers = { 'User-Agent' : 'AWS Lambda' }) if not validate ( str ( urlopen ( req ) . read ())): raise Exception ( 'Validation failed' ) except : print ( 'Check failed!' ) raise else : print ( 'Check passed!' ) return ( 'aquasec.com is up! at {} ' . format ( timeNow )) finally : print ( 'Check complete at {} ' . format ( str ( datetime . now ()))) Inspired by: https://github.com/amazon-archives/serverless-app-examples/blob/master/python/lambda-canary/lambda_function.py","title":"Lambda Config"},{"location":"blueprints/image-processing/","text":"Doing Serverless Image Recognition using Postee Actions and AWS \u00b6 Introduction \u00b6 In this walkthrough, we will setup Postee Actions by re-using existing AWS Lambda Functions. This will allow anyone to configure and re-use existing AWS Lambda functionality as a Postee Action. Scenario \u00b6 A user wants to be able to setup image processing of captured images in order to be able to identify any suspicious activity captured by the security (CCTV) camera. Upon successful identification, the user should be informed of such an event. Sample Configs \u00b6 In this case a sample configuration for the components can be described as follows: Postee Config \u00b6 routes : - name : actions-route input : contains(input.Camera.Event, \"Finding\") serialize-actions : true actions : [ send-slack-message , process-image ] # Outputs are target services that should consume the messages actions : - name : send-slack-messsage type : slack enable : true url : https://hooks.slack.com/services/TAAAA/BBB/<key> - name : process-image type : http enable : true url : \"https://<uuid-func>.lambda-url.<aws-region>.on.aws/\" method : POST AWS Rekognition & Lambda Config \u00b6 The full source code is omitted here for brevity but this example was inspired by: https://docs.aws.amazon.com/code-samples/latest/catalog/python-rekognition-rekognition_video_detection.py.html In order to setup the Lambda function we will need a handler that can process the incoming event from Postee. The below example demonstrates via Python psuedocode what this Lambda Handler could look like. import boto3 from rekognition_objects import ( RekognitionFace , RekognitionVideo ) def do_face_detection ( self ): return self . _do_rekognition_job ( \"face detection\" , self . rekognition_client . start_face_detection , self . rekognition_client . get_face_detection , lambda response : [ RekognitionFace ( face [ 'Face' ], face [ 'Timestamp' ]) for face in response [ 'Faces' ]]) def lambda_handler ( event , context ): rekognition_client = boto3 . client ( 'rekognition' ) video = RekognitionVideo . from_event ( event , rekognition_client ) faces = video . do_face_detection () return faces","title":"Image Processing"},{"location":"blueprints/image-processing/#doing-serverless-image-recognition-using-postee-actions-and-aws","text":"","title":"Doing Serverless Image Recognition using Postee Actions and AWS"},{"location":"blueprints/image-processing/#introduction","text":"In this walkthrough, we will setup Postee Actions by re-using existing AWS Lambda Functions. This will allow anyone to configure and re-use existing AWS Lambda functionality as a Postee Action.","title":"Introduction"},{"location":"blueprints/image-processing/#scenario","text":"A user wants to be able to setup image processing of captured images in order to be able to identify any suspicious activity captured by the security (CCTV) camera. Upon successful identification, the user should be informed of such an event.","title":"Scenario"},{"location":"blueprints/image-processing/#sample-configs","text":"In this case a sample configuration for the components can be described as follows:","title":"Sample Configs"},{"location":"blueprints/image-processing/#postee-config","text":"routes : - name : actions-route input : contains(input.Camera.Event, \"Finding\") serialize-actions : true actions : [ send-slack-message , process-image ] # Outputs are target services that should consume the messages actions : - name : send-slack-messsage type : slack enable : true url : https://hooks.slack.com/services/TAAAA/BBB/<key> - name : process-image type : http enable : true url : \"https://<uuid-func>.lambda-url.<aws-region>.on.aws/\" method : POST","title":"Postee Config"},{"location":"blueprints/image-processing/#aws-rekognition-lambda-config","text":"The full source code is omitted here for brevity but this example was inspired by: https://docs.aws.amazon.com/code-samples/latest/catalog/python-rekognition-rekognition_video_detection.py.html In order to setup the Lambda function we will need a handler that can process the incoming event from Postee. The below example demonstrates via Python psuedocode what this Lambda Handler could look like. import boto3 from rekognition_objects import ( RekognitionFace , RekognitionVideo ) def do_face_detection ( self ): return self . _do_rekognition_job ( \"face detection\" , self . rekognition_client . start_face_detection , self . rekognition_client . get_face_detection , lambda response : [ RekognitionFace ( face [ 'Face' ], face [ 'Timestamp' ]) for face in response [ 'Faces' ]]) def lambda_handler ( event , context ): rekognition_client = boto3 . client ( 'rekognition' ) video = RekognitionVideo . from_event ( event , rekognition_client ) faces = video . do_face_detection () return faces","title":"AWS Rekognition &amp; Lambda Config"}]}